using System.Collections;
using UnityEngine;
using UnityEngine.VFX;

[RequireComponent(typeof(AudioSource))]
public class PhotoCamera : MonoBehaviour
{
    [Header("Camera")]
    [Tooltip("Camera inside the PhotoCamera prefab that is going to take the photo.")]
    [SerializeField] private Camera _camera;
    [Tooltip("Output transform where we are going to instantiate the photo taken.")]
    [SerializeField] private Transform _output;
    [Tooltip("Sound that is going to be played when camera is activated.")]
    [SerializeField] private AudioClip _cameraSound;
    [Tooltip("Visual Effect used to simulate the camera flash while taking a photo.")]
    [SerializeField] private VisualEffect _flashEffect;

    [Header("Photo")]
    [Tooltip("Photo prefab that is going to be instantiated when the camera is activated.")]
    [SerializeField] private GameObject _photoPrefab;

    [Range(2, 4)]
    [Tooltip("Delay until camera can be used again. The min value is matching the length of the camera sound.")]
    [SerializeField] private int _photoDelay;

    private bool _canShot; // Boolean variable to ensure the camera has a delay.
    private AudioSource _audioSource; // Audio source used to play the shoting sound.


    void Awake()
    {
        _canShot = true;
        _flashEffect.Stop();
        _audioSource = GetComponent<AudioSource>(); 
    }

    /*
        Public method that is called by the Activated Event on the 
        XR Offset Interactable script
    */
    public void TakeShot()
    {
        if (_canShot)
        {
            StartCoroutine(TakeShotRoutine());
        }
    }

    /*
        Method that takes the RenderTexture from the camera and transforms 
        it into a material, then instantiates a new photo with that material.
        Once the photo is instantiated, bool _canShot is setted to false and
        ShotingDelay coroutine is started in order to wait _photoDelay seconds
        until the next shot.
    */
    IEnumerator TakeShotRoutine()
    {
        yield return new WaitForEndOfFrame();

        // Take the renderTexture generated by the camera.
        RenderTexture renderTexture = _camera.targetTexture;

        // As ReadPixels uses the active RenderTexture we are going to set the
        // active with the camera renderTexture and later restore its value.
        var oldRenderTexture = RenderTexture.active;
        RenderTexture.active = renderTexture;

        // Generates the Texture2D with the size of the renderTexture from the camera.
        Texture2D photoTexture = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.ARGB32, false);
        photoTexture.ReadPixels(new Rect(0, 0, renderTexture.width, renderTexture.height), 0, 0);
        photoTexture.Apply();

        // Restore active RenderTexture to its default value
        RenderTexture.active = oldRenderTexture;

        // Creates the material using URP and sets the mainTexture to the Texture2D we have created.
        Material photoMaterial = new Material(Shader.Find("Universal Render Pipeline/Lit"));
        photoMaterial.mainTexture = photoTexture;

        // Instantiate the photoPrefab in the output position of the camera.
        var go = Instantiate(_photoPrefab, _output.position, _output.rotation, _output);
        go.transform.Find("Image").GetComponent<MeshRenderer>().material = photoMaterial;

        // Sets the photo's delay time (photo coming out) to the same as the camera's. 
        go.GetComponent<Photo>().SetDelayTime(_photoDelay);

        // Plays the audio of the shot being taken.
        _audioSource.PlayOneShot(_cameraSound);

        // Plays the visual effect that simulates the flash.
        _flashEffect.Play();

        // Sets canShot to false and then starts delay Coroutine
        _canShot = false;
        StartCoroutine(ShotingDelay());
    }


    /*
        Coroutine that waits _photoDelay seconds and then sets the
        _canShot boolean to true in order to be able to take another
        shot.
    */
    IEnumerator ShotingDelay()
    {
        yield return new WaitForSeconds(_photoDelay);
        _canShot = true;
    }
}
